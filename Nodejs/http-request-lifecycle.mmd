flowchart TD
    Start([ğŸŒ Client Sends HTTP Request]) --> Phase1[ğŸ“¦ PHASE 1: Network & OS Layer]
    
    Phase1 --> Step1["ğŸ”Œ Step 1: Network Packet Arrives<br/>â€¢ TCP packet travels through network<br/>â€¢ Arrives at server NIC"]
    Step1 --> Step2["ğŸ” Step 2: TCP Processing<br/>â€¢ Kernel validates packet<br/>â€¢ TCP handshake if new connection<br/>â€¢ Socket â†’ ESTABLISHED state"]
    Step2 --> Step3["ğŸ’¾ Step 3: Kernel Buffering<br/>â€¢ Data â†’ TCP receive buffer<br/>â€¢ SO_RCVBUF ~200KB"]
    Step3 --> Step4["ğŸ“¢ Step 4: Event Notification<br/>â€¢ Kernel marks socket readable<br/>â€¢ epoll/kqueue/IOCP notified"]
    
    Step4 --> Phase2[âš¡ PHASE 2: Event Loop Poll Phase]
    
    Phase2 --> Step5["ğŸ”„ Step 5: Poll Phase Activation<br/>â€¢ Event loop enters poll phase<br/>â€¢ epoll_wait returns ready sockets"]
    Step5 --> Step6["ğŸ“– Step 6: Socket Read Operation<br/>â€¢ libuv reads from socket<br/>â€¢ Non-blocking read from kernel"]
    Step6 --> Step7["ğŸ” Step 7: HTTP Parsing Begins<br/>â€¢ llhttp parser processes request<br/>â€¢ Extracts: method, URL, version"]
    Step7 --> Step8["ğŸ“‹ Step 8: Header Parsing<br/>â€¢ Parser reads headers line by line<br/>â€¢ Headers end with \\r\\n\\r\\n"]
    Step8 --> Step9["ğŸ¯ Step 9: Request Object Creation<br/>â€¢ Create IncomingMessage req<br/>â€¢ Create ServerResponse res"]
    Step9 --> Step10["ğŸš€ Step 10: Handler Invocation<br/>â€¢ Server emits 'request' event<br/>â€¢ Handler called synchronously"]
    
    Step10 --> Phase3[ğŸ’» PHASE 3: Application Processing]
    
    Phase3 --> Step11["âš™ï¸ Step 11: Handler Execution<br/>â€¢ Your code processes request<br/>â€¢ May perform async operations"]
    Step11 --> Step12["ğŸ“ Step 12: Response Preparation<br/>â€¢ Set response headers<br/>â€¢ Write response body"]
    
    Step12 --> Phase4[ğŸ“¤ PHASE 4: Response Sending]
    
    Phase4 --> Step13["âœï¸ Step 13: Response Writing<br/>â€¢ Data â†’ response buffer<br/>â€¢ Backpressure handling"]
    Step13 --> Step14["ğŸ“¡ Step 14: Socket Write Operation<br/>â€¢ libuv writes to socket<br/>â€¢ Non-blocking write to kernel"]
    Step14 --> Step15["ğŸ”§ Step 15: Kernel Network Stack<br/>â€¢ TCP segments data into packets<br/>â€¢ Adds TCP headers, checksums"]
    Step15 --> Step16["ğŸŒ Step 16: Network Transmission<br/>â€¢ Packets travel to client<br/>â€¢ Client receives and processes"]
    
    Step16 --> Phase5[ğŸ§¹ PHASE 5: Connection Cleanup]
    
    Phase5 --> Step17["âœ… Step 17: Response Completion<br/>â€¢ res.end called and flushed<br/>â€¢ Connection decision point"]
    Step17 --> Decision{ğŸ”€ Connection<br/>Closing?}
    Decision -->|Yes| Step18["ğŸ”’ Step 18: Connection Closure<br/>â€¢ FIN/ACK handshake<br/>â€¢ Socket â†’ CLOSED state"]
    Decision -->|No, Keep-Alive| KeepAlive["â™»ï¸ Connection Kept Open<br/>â€¢ Reuse for next request<br/>â€¢ Timeout after idle period"]
    Step18 --> Step19["ğŸ—‘ï¸ Step 19: Close Phase Cleanup<br/>â€¢ Remove from epoll watch list<br/>â€¢ Close file descriptor<br/>â€¢ Free memory buffers"]
    KeepAlive -.->|Eventually| Step19
    Step19 --> End([âœ¨ End])
    
    style Phase1 fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    style Phase2 fill:#fff4e1,stroke:#f57c00,stroke-width:3px
    style Phase3 fill:#e8f5e9,stroke:#388e3c,stroke-width:3px
    style Phase4 fill:#fce4ec,stroke:#c2185b,stroke-width:3px
    style Phase5 fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px
    style Start fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style End fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style Decision fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style KeepAlive fill:#e1bee7,stroke:#8e24aa,stroke-width:2px
